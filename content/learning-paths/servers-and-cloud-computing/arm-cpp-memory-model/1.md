---
title: Introduction to Memory Models
weight: 2

### FIXED, DO NOT MODIFY
layout: learningpathall
---

## What is a memory model?

A language’s memory model defines how operations on shared data interleave at runtime, providing rules on what reorderings are allowed by compilers and hardware. In C++, the memory model specifies how threads interact with shared variables, ensuring consistent behavior across different compilers and architectures. A developer can think of program ordering in 4 broad buckets.

-  **Source Code Order** The exact sequence in which you write statements. This is the most intuitive view because it directly reflects how code appears to you.

```output
int x = 5; // first
int z = x * 5 // second
int y = 42 // third 
```

- **Program Order**: The logical sequence recognized by the compiler, which may rearrange or optimize instructions under certain constraints for an output binary (i.e. program) that takes fewer cycles. Although the statements may appear in a particular order in your source, the compiler could restructure them if it deems it safe.

```output
LDR R1 #5 //
LDR R2 #42 // third
MULT R3, #R1, #5 // second
```

- **Execution Order**: How instructions are actually issued and executed by the hardware. Modern CPUs often employ out-of-order execution for performance. For instance, on an ARM-based system, you might see assembly lines like:

```output
MOV W0, #1   ; Move immediate value 1 into register W0
STR W0, [X1] ; Store register W0 to the memory address in X1
```

Even though the instructions are listed in one order, the CPU might reorder their micro-operations as long as it respects dependencies.

• Hardware Perceived Order: The perspective observed by other devices or the rest of the system, which can differ if the hardware buffers writes or merges memory operations.

For example, in the code:

x = 1;
y = 2;

the compiler or CPU may interchange these assignments if it believes no observable effect changes.


## Difference between hardware and language memory models

Sequential consistency is a strict model that mandates all operations appear in one global order exactly matching source code order across all threads. This greatly simplifies reasoning about concurrency but can be expensive to enforce, since it limits many hardware and compiler optimizations.

Conversely, relaxed memory models permit more reorderings, boosting performance but requiring developers to handle more intricate synchronization concerns. A strong memory model, on the other hand, offers simpler guarantees about program behavior yet demands more from the system to uphold these guarantees.
