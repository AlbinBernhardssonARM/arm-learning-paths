---
title: C++ Memory Model and Atomics
weight: 3

### FIXED, DO NOT MODIFY
layout: learningpathall
---

## C++ Memory Model

The C++ memory model provides a unified framework for multi-threaded programming across various compilers and CPU architectures. Crucially, it was formally introduced in C++11, which standardized concurrency semantics that were previously only partially specified. By defining how loads and stores can be ordered, the model helps developers write correct code that behaves predictably under optimization and out-of-order execution. This is essential in an era where multi-core processors are the norm, each potentially handling instructions differently. Without these rules, seemingly correct programs could yield unexpected behaviors when migrated from x86 to AArch64 with different microarchitectural features. 

Other languages also define memory models to manage concurrent operations and guarantee certain behaviors. Java, for example, has a detailed memory model describing visibility and ordering of shared variables. The .NET environment includes a memory model for C# and other languages on its platform. Such models ensure consistency and portability, allowing programmers to develop safe, performant applications without relying on undefined or unspecified behaviour.

### Expanding Memory Model for Multiple Threads

One of the major expansions in modern C++ has been the formalization of the memory model to handle multiple threads. In single-threaded code, the compiler is free to reorder instructions as it sees fit, provided the final observable behavior remains the same. This flexibility is commonly referred to as the “as-if” rule, ensuring that any reordering does not alter inputs, outputs, or volatile access. For further reading please see the [C++ reference](https://en.cppreference.com/w/cpp/language/as_if). However, when multiple threads enter the picture, preserving consistent and correct behavior requires additional considerations.

Enter the concept of “happens-before.” Instead of letting operations in different threads float freely, the C++ memory model ties them together with synchronization primitives like mutexes and atomic operations. These mechanisms establish a “happens-before” relationship, which means writes performed in one thread become visible to other threads in a well-defined order. Without proper synchronization, a simple reordering might cause one thread to read stale data written by another thread, leading to undefined outcomes.

## C++ Atomic Memory Ordering

In C++, `std::memory_order` atomic operations allow developers to specify how memory accesses, including regular, non-atomic memory accesses are order among atomic operation. Choosing the right memory order is crucial for balancing performance and correctness. Assume we have 2 atomic integers with initial values of 0:

```c++
std::atomic<int> x{0};
std::atomic<int> y{0};
```

Below are a few of C++’s atomic memory orders, along with a short code snippet illustrating what might or might not be reordered.

- `memory_order_relaxed`

Relaxed operations do not impose ordering constraints beyond atomicity. They can be freely reordered with respect to other operations. This provides maximum performance but can lead to visibility issues if used incorrectly.

```c++
// Thread A:
r1 = y.load(std::memory_order_relaxed); // A
x.store(r1, std::memory_order_relaxed); // B
// Thread B:
r2 = x.load(std::memory_order_relaxed); // C 
y.store(42, std::memory_order_relaxed); // D
// These two stores could appear in any order relative to each other.
```

- `memory_order_acquire`

Used for operations that perform a read. Acquire ensures that no subsequent reads or writes can move before this load. It’s used to see the effects of operations from another thread that performed a release.

```c++

```

- `memory_order_release`

Used for operations that perform a write. Release prevents preceding writes from moving after the release operation. It’s used so that another thread with an acquire on the same variable can safely observe earlier writes.

```c++

```

- `memory_order_acq_rel`

Used for operations that perform a read-modify-write. Release prevents preceding writes from moving after the release operation. It’s used so that another thread with an acquire on the same variable can safely observe earlier writes.

```c++

```

- `memory_order_seq_cst`

sequential consistency is the strongest order and the default ordering if nothing is specified. 

```c++

```


## Differences between x86 and AArch64 memory model


