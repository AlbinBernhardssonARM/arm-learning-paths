---
title: C++ Memory Model and Atomics
weight: 3

### FIXED, DO NOT MODIFY
layout: learningpathall
---

## C++ Memory Model for Single Threads


For a long time, writing C++ programs on single-core systems was relatively straightforward. The compiler could reorder instructions however it wished, so long as the program’s observable behavior remained unchanged. This optimization freedom is commonly referred to as the “as-if” rule. Essentially, compilers can optimize away or move instructions around as if the code had not changed, provided they do not affect inputs, outputs, or volatile accesses.

That single-threaded world was simpler: you wrote code, the compiler made it faster (by reordering or eliding instructions if safe), and everyone benefited. But then multi-core processors and multi-threaded applications became the norm. Suddenly, reordering instructions was not merely about performance—it could change the meaning of programs with threads reading and writing shared data simultaneously.

### Expanding Memory Model for Multiple Threads

When multi-threading gained traction, compilers and CPUs need more precise rules about what reordering is allowed. This is where the formalized C++ memory model, introduced in C++11, steps in. Prior to C++11, concurrency in C++ was partially specified and relied on platform-specific behavior. Now, the language standard includes well-defined semantics ensuring that developers writing concurrent code can rely on a set of guaranteed rules.

Under the new model, if a piece of data is shared between threads without proper synchronization, you can no longer assume it behaves like single-threaded code. Instead, operations on this shared data may be reordered unless you explicitly prevent it using atomic operations or other synchronization primitives such as mutexes. To ensure correctness, C++ provides an array of memory orders (such as std::memory_order_relaxed, std::memory_order_acquire, std::memory_order_release, etc.) that govern how loads and stores can be observed in a multi-threaded environment. Details can be found on cppreference.com’s section on memory ordering.

## C++ Atomic Memory Ordering

In C++, `std::memory_order` atomic operations allow developers to specify how memory accesses, including regular, non-atomic memory accesses are order among atomic operation. Choosing the right memory order is crucial for balancing performance and correctness. Assume we have 2 atomic integers with initial values of 0:

```c++
std::atomic<int> x{0};
std::atomic<int> y{0};
```

Below are a few of C++’s atomic memory orders, along with a short code snippet illustrating what might or might not be reordered.

- `memory_order_relaxed`

Relaxed operations do not impose ordering constraints beyond atomicity. They can be freely reordered with respect to other operations. This provides maximum performance but can lead to visibility issues if used incorrectly.

```c++
// Thread A:
r1 = y.load(std::memory_order_relaxed); // A
x.store(r1, std::memory_order_relaxed); // B

// Thread B:
r2 = x.load(std::memory_order_relaxed); // C 
y.store(42, std::memory_order_relaxed); // D
// These two stores could appear in any order relative to each other.
```

In the pseudo code snippet above, it's possible for operation B to precede operation C, or the mirror possibility of D executing before A. 

- `memory_order_acquire` and `memory_order_release`

Memory order acquire and release are used to synchronize values between threads. Hence for the 

```c++
// Thread A:
r1 = y.load(std::memory_order_acquire); // A
x.store(r1, std::memory_order_release); // B
// Thread B:
r2 = x.load(std::memory_order_acquire); // C 
y.store(42, std::memory_order_release); // D
// These two stores could appear in any order relative to each other.
```


- `memory_order_seq_cst`

sequential consistency is the strongest order and the default ordering if nothing is specified. 

For information on all possible memory ordering possibilities and their nuances, please refer to the [C++ reference](https://en.cppreference.com/w/cpp/atomic/memory_order).




